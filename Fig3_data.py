# This code generates the curve where the optimal contorl changes its sign. It is generated by dividing the phase space into small boxes and cheking inside of each box which control is optimal. After that, the curve where the change of sign happens is extracted and saved to a file.
import numpy as np
import sys
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import scipy.integrate as integr

mu = 0.1
k = float(sys.argv[1])

#  Limit cycle data:
data = np.loadtxt('limitcycle.dat')
xfs = data[:, 0]
vfs = data[:, 1]

# Interpolation of the limit cycle data:
mask = vfs > 0
xfs_pos = xfs[mask]
vfs_pos = vfs[mask]
sort_idx_pos = np.argsort(xfs_pos)
xfs_pos_sorted = xfs_pos[sort_idx_pos]
vfs_pos_sorted = vfs_pos[sort_idx_pos]

def vf_pos(x):
    return np.interp(x, xfs_pos_sorted, vfs_pos_sorted)

mask2 = vfs < 0
xfs_neg = xfs[mask2]
vfs_neg = vfs[mask2]
sort_idx_neg = np.argsort(xfs_neg)
xfs_neg_sorted = xfs_neg[sort_idx_neg]
vfs_neg_sorted = vfs_neg[sort_idx_neg]

def vf_neg(x):
    return np.interp(x, xfs_neg_sorted, vfs_neg_sorted)

x_div = xfs[np.argmin(vfs)]
mask3 = xfs > x_div
xfs_pos2 = xfs[mask3]
vfs_pos2 = vfs[mask3]
sort_idv_pos = np.argsort(vfs_pos2)
xfs_pos_sorted2 = xfs_pos2[sort_idv_pos]
vfs_pos_sorted2 = vfs_pos2[sort_idv_pos]

def xf_pos(v):
    return np.interp(v, vfs_pos_sorted2, xfs_pos_sorted2)

mask4 = xfs < x_div
xfs_neg2 = xfs[mask4]
vfs_neg2 = vfs[mask4]
sort_idv_neg = np.argsort(vfs_neg2)
xfs_neg_sorted2 = xfs_neg2[sort_idv_neg]
vfs_neg_sorted2 = vfs_neg2[sort_idv_neg]

def xf_neg(v):
    return np.interp(v, vfs_neg_sorted2, xfs_neg_sorted2)

t_exp = 10
t_s10 = -t_exp

xmin, xmax = -2.1, 2.1
vmin, vmax = -2.1, 2.1
Nx, Nv = 300, 300
dx = (xmax - xmin) / Nx
dv = (vmax - vmin) / Nv

min_time_grid = np.full((Nx, Nv), np.inf)
winner_grid = np.zeros((Nx, Nv))


color_grid = np.full((Nx, Nv, 3), np.nan)

def find_box(x, v):
    if x < xmin or x >= xmax or v < vmin or v >= vmax:
        return None
    i = int((x - xmin) / dx)
    j = int((v - vmin) / dv)
    return i, j

def f(t, u):
    x, v, p1, p2 = u
    return [v, mu * (1 - x**2) * v - x + F, mu * p2 * 2 * x * v + p2, mu * p2 * (x**2 - 1) - p1]

def update_grids_from_solution(sol, F, color):
    t_dense = np.linspace(sol.t[0], sol.t[-1], 500)
    sol_dense = sol.sol(t_dense)
    for idx in range(len(t_dense)):
        x, v = sol_dense[0, idx], sol_dense[1, idx]
        box = find_box(x, v)
        if box is not None:
            i_box, j_box = box
            t_new = -t_dense[idx]
            if t_new < min_time_grid[i_box, j_box]:
                min_time_grid[i_box, j_box] = t_new
                winner_grid[i_box, j_box] = np.sign(F)
                color_grid[i_box, j_box, :] = color

reds = ['purple', "#16d1de", 'yellow', 'green', 'orange']

def lighten_color(color, amount=0.5):
    rgb = np.array(mcolors.to_rgb(color))
    white = np.array([1, 1, 1])
    return tuple(rgb + (white - rgb) * amount)

blues = [lighten_color(c, 0.4) for c in reds]

for i in range(len(xfs)):
    xf = xfs[i]
    vf = vfs[i]
    F = k if vf > 0 else -k
    t_start = 0
    state = [xf, vf, -(mu * (1 - xf**2) * vf - xf) / (F * vf), 1 / F]

    for n_control in range(5):
        def event(t, y):
            return y[3]
        event.terminal = True
        event.direction = -np.sign(F)

        if F > 0:
            def event_ciclo(t, y):
                return vf_neg(y[0]) - y[1]
            event_ciclo.direction = 1
        else:
            def event_ciclo(t, y):
                return vf_pos(y[0]) - y[1]
            event_ciclo.direction = -1
        event_ciclo.terminal = True

        sol = integr.solve_ivp(f, [t_start, t_s10], state,
                               method='Radau', rtol=1e-6, atol=1e-6,
                               events=[event, event_ciclo], dense_output=True)

        color = mcolors.to_rgb(reds[n_control]) if F > 0 else blues[n_control]
        update_grids_from_solution(sol, F, color)
        if sol.t_events[0].size == 0:
            break
        t_start = sol.t_events[0][0]
        state = sol.y_events[0][0]
        F = -F

# Curve where the control changes sign. It is found by checking neighboring boxes for different signs and saving the center point of the box where the change happens.
interface_points = []
for i in range(Nx - 1):
    for j in range(Nv - 1):
        w00 = winner_grid[i, j]
        vecinos = [winner_grid[i+1, j], winner_grid[i, j+1],
                   winner_grid[i+1, j+1], winner_grid[i+1, j-1] if j > 0 else w00]
        for w in vecinos:
            if w != 0 and w00 != 0 and w * w00 < 0:
                x = xmin + (i + 0.5) * dx
                v = vmin + (j + 0.5) * dv
                interface_points.append((x, v))
                break

np.savetxt('reds_blues' + str(k) + '.dat', interface_points)
